// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const createCompany = `-- name: CreateCompany :one
INSERT INTO tb_companies (company_name)
VALUES ($1) RETURNING id_company
`

func (q *Queries) CreateCompany(ctx context.Context, companyName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, createCompany, companyName)
	var id_company int64
	err := row.Scan(&id_company)
	return id_company, err
}

const createDeposit = `-- name: CreateDeposit :one
INSERT INTO tb_deposits (deposit_name, company_id)
values ($1, $2) RETURNING id_deposit
`

type CreateDepositParams struct {
	DepositName string
	CompanyID   int64
}

func (q *Queries) CreateDeposit(ctx context.Context, arg CreateDepositParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createDeposit, arg.DepositName, arg.CompanyID)
	var id_deposit int64
	err := row.Scan(&id_deposit)
	return id_deposit, err
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO tb_groups (group_name)
values ($1) RETURNING id_group
`

func (q *Queries) CreateGroup(ctx context.Context, groupName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, createGroup, groupName)
	var id_group int64
	err := row.Scan(&id_group)
	return id_group, err
}

const createMaterial = `-- name: CreateMaterial :exec
INSERT INTO tb_materials (material_name, material_brand, material_power, material_amps, material_length, buy_unit,
                          request_unit, id_material_type, id_company, id_deposit)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type CreateMaterialParams struct {
	MaterialName   string
	MaterialBrand  sql.NullString
	MaterialPower  sql.NullString
	MaterialAmps   sql.NullString
	MaterialLength sql.NullString
	BuyUnit        string
	RequestUnit    string
	IDMaterialType int64
	IDCompany      int64
	IDDeposit      int64
}

func (q *Queries) CreateMaterial(ctx context.Context, arg CreateMaterialParams) error {
	_, err := q.db.ExecContext(ctx, createMaterial,
		arg.MaterialName,
		arg.MaterialBrand,
		arg.MaterialPower,
		arg.MaterialAmps,
		arg.MaterialLength,
		arg.BuyUnit,
		arg.RequestUnit,
		arg.IDMaterialType,
		arg.IDCompany,
		arg.IDDeposit,
	)
	return err
}

const createType = `-- name: CreateType :one
INSERT INTO tb_types (id_group, type_name)
values ($1, $2) RETURNING id_type
`

type CreateTypeParams struct {
	IDGroup  int64
	TypeName string
}

func (q *Queries) CreateType(ctx context.Context, arg CreateTypeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createType, arg.IDGroup, arg.TypeName)
	var id_type int64
	err := row.Scan(&id_type)
	return id_type, err
}

const existsByGroupName = `-- name: ExistsByGroupName :one
select id_group
from tb_groups
where (unaccent(lower(group_name)) = $1 or lower(group_name) = $1) limit 1
`

func (q *Queries) ExistsByGroupName(ctx context.Context, groupName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, existsByGroupName, groupName)
	var id_group int64
	err := row.Scan(&id_group)
	return id_group, err
}

const existsCompanyByName = `-- name: ExistsCompanyByName :one
select id_company
from tb_companies
where (unaccent(lower(company_name)) = $1 or lower(company_name) = $1) limit 1
`

func (q *Queries) ExistsCompanyByName(ctx context.Context, companyName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, existsCompanyByName, companyName)
	var id_company int64
	err := row.Scan(&id_company)
	return id_company, err
}

const existsDepositByName = `-- name: ExistsDepositByName :one
select id_deposit
from tb_deposits
where (unaccent(lower(deposit_name)) = $1 or lower(deposit_name) = $1) limit 1
`

func (q *Queries) ExistsDepositByName(ctx context.Context, depositName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, existsDepositByName, depositName)
	var id_deposit int64
	err := row.Scan(&id_deposit)
	return id_deposit, err
}

const existsMaterialByName = `-- name: ExistsMaterialByName :one
select id_material
from tb_materials tm
         join tb_deposits td on td.id_deposit = tm.id_deposit
where (unaccent(Lower(tm.material_name)) = $1 or Lower(tm.material_name) = $1)
  and (unaccent(Lower(coalesce(tm.material_brand,''))) = coalesce($2, '') or Lower(coalesce(tm.material_brand,'')) = coalesce($2, ''))
  and (unaccent(Lower(coalesce(tm.material_power,''))) = coalesce($3, '')or Lower(coalesce(tm.material_power,'')) = coalesce($3, ''))
  and (unaccent(Lower(coalesce(tm.material_length,''))) = coalesce($4, '')or Lower(coalesce(tm.material_length,'')) = coalesce($4, ''))
  and (unaccent(Lower(td.deposit_name)) = $5 or Lower(td.deposit_name) = $5) limit 1
`

type ExistsMaterialByNameParams struct {
	MaterialName   string
	MaterialBrand  sql.NullString
	MaterialPower  sql.NullString
	MaterialLength sql.NullString
	DepositName    string
}

func (q *Queries) ExistsMaterialByName(ctx context.Context, arg ExistsMaterialByNameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, existsMaterialByName,
		arg.MaterialName,
		arg.MaterialBrand,
		arg.MaterialPower,
		arg.MaterialLength,
		arg.DepositName,
	)
	var id_material int64
	err := row.Scan(&id_material)
	return id_material, err
}

const existsTypeByName = `-- name: ExistsTypeByName :one
select id_type
from tb_types
where (unaccent(lower(type_name)) = $1 or lower(type_name) = $1) limit 1
`

func (q *Queries) ExistsTypeByName(ctx context.Context, typeName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, existsTypeByName, typeName)
	var id_type int64
	err := row.Scan(&id_type)
	return id_type, err
}

const getCompanies = `-- name: GetCompanies :many
select id_company, company_name
from tb_companies
`

func (q *Queries) GetCompanies(ctx context.Context) ([]TbCompany, error) {
	rows, err := q.db.QueryContext(ctx, getCompanies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TbCompany
	for rows.Next() {
		var i TbCompany
		if err := rows.Scan(&i.IDCompany, &i.CompanyName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompany = `-- name: GetCompany :one
select id_company, company_name
from tb_companies
where id_company = $1 limit 1
`

func (q *Queries) GetCompany(ctx context.Context, idCompany int64) (TbCompany, error) {
	row := q.db.QueryRowContext(ctx, getCompany, idCompany)
	var i TbCompany
	err := row.Scan(&i.IDCompany, &i.CompanyName)
	return i, err
}

const getDeposit = `-- name: GetDeposit :one
select company_id, id_deposit, deposit_name
from tb_deposits
where id_deposit = $1 limit 1
`

func (q *Queries) GetDeposit(ctx context.Context, idDeposit int64) (TbDeposit, error) {
	row := q.db.QueryRowContext(ctx, getDeposit, idDeposit)
	var i TbDeposit
	err := row.Scan(&i.CompanyID, &i.IDDeposit, &i.DepositName)
	return i, err
}

const getDeposits = `-- name: GetDeposits :many
select company_id, id_deposit, deposit_name
from tb_deposits
`

func (q *Queries) GetDeposits(ctx context.Context) ([]TbDeposit, error) {
	rows, err := q.db.QueryContext(ctx, getDeposits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TbDeposit
	for rows.Next() {
		var i TbDeposit
		if err := rows.Scan(&i.CompanyID, &i.IDDeposit, &i.DepositName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroup = `-- name: GetGroup :one
select id_group, group_name
from tb_groups
where id_group = $1 limit 1
`

func (q *Queries) GetGroup(ctx context.Context, idGroup int64) (TbGroup, error) {
	row := q.db.QueryRowContext(ctx, getGroup, idGroup)
	var i TbGroup
	err := row.Scan(&i.IDGroup, &i.GroupName)
	return i, err
}

const getGroups = `-- name: GetGroups :many
select id_group, group_name
from tb_groups
`

func (q *Queries) GetGroups(ctx context.Context) ([]TbGroup, error) {
	rows, err := q.db.QueryContext(ctx, getGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TbGroup
	for rows.Next() {
		var i TbGroup
		if err := rows.Scan(&i.IDGroup, &i.GroupName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaterial = `-- name: GetMaterial :one
select cost_price, inactive, stock_available, stock_quantity, id_company, id_deposit, id_material, id_material_type, buy_unit, material_amps, material_brand, material_length, material_name, material_power, request_unit
from tb_materials
where id_material = $1 limit 1
`

func (q *Queries) GetMaterial(ctx context.Context, idMaterial int64) (TbMaterial, error) {
	row := q.db.QueryRowContext(ctx, getMaterial, idMaterial)
	var i TbMaterial
	err := row.Scan(
		&i.CostPrice,
		&i.Inactive,
		&i.StockAvailable,
		&i.StockQuantity,
		&i.IDCompany,
		&i.IDDeposit,
		&i.IDMaterial,
		&i.IDMaterialType,
		&i.BuyUnit,
		&i.MaterialAmps,
		&i.MaterialBrand,
		&i.MaterialLength,
		&i.MaterialName,
		&i.MaterialPower,
		&i.RequestUnit,
	)
	return i, err
}

const getMaterials = `-- name: GetMaterials :many
select cost_price, inactive, stock_available, stock_quantity, id_company, id_deposit, id_material, id_material_type, buy_unit, material_amps, material_brand, material_length, material_name, material_power, request_unit
from tb_materials
`

func (q *Queries) GetMaterials(ctx context.Context) ([]TbMaterial, error) {
	rows, err := q.db.QueryContext(ctx, getMaterials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TbMaterial
	for rows.Next() {
		var i TbMaterial
		if err := rows.Scan(
			&i.CostPrice,
			&i.Inactive,
			&i.StockAvailable,
			&i.StockQuantity,
			&i.IDCompany,
			&i.IDDeposit,
			&i.IDMaterial,
			&i.IDMaterialType,
			&i.BuyUnit,
			&i.MaterialAmps,
			&i.MaterialBrand,
			&i.MaterialLength,
			&i.MaterialName,
			&i.MaterialPower,
			&i.RequestUnit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaterialsWithRelationship = `-- name: GetMaterialsWithRelationship :many
select tm.material_name,
       tm.material_brand,
       tm.material_power,
       tm.material_amps,
       tm.material_length,
       tm.buy_unit,
       tm.request_unit,
       tt.type_name,
       tg.group_name,
       tc.company_name,
       td.deposit_name
from tb_materials tm
         join tb_types tt on tt.id_type = tm.id_material_type
         join tb_groups tg on tg.id_group = tt.id_group
         join tb_companies tc on tc.id_company = tm.id_company
         join tb_deposits td on td.id_deposit = tm.id_deposit
`

type GetMaterialsWithRelationshipRow struct {
	MaterialName   string
	MaterialBrand  sql.NullString
	MaterialPower  sql.NullString
	MaterialAmps   sql.NullString
	MaterialLength sql.NullString
	BuyUnit        string
	RequestUnit    string
	TypeName       string
	GroupName      string
	CompanyName    string
	DepositName    string
}

func (q *Queries) GetMaterialsWithRelationship(ctx context.Context) ([]GetMaterialsWithRelationshipRow, error) {
	rows, err := q.db.QueryContext(ctx, getMaterialsWithRelationship)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMaterialsWithRelationshipRow
	for rows.Next() {
		var i GetMaterialsWithRelationshipRow
		if err := rows.Scan(
			&i.MaterialName,
			&i.MaterialBrand,
			&i.MaterialPower,
			&i.MaterialAmps,
			&i.MaterialLength,
			&i.BuyUnit,
			&i.RequestUnit,
			&i.TypeName,
			&i.GroupName,
			&i.CompanyName,
			&i.DepositName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getType = `-- name: GetType :one
select id_group, id_type, type_name
from tb_types
where id_type = $1 limit 1
`

func (q *Queries) GetType(ctx context.Context, idType int64) (TbType, error) {
	row := q.db.QueryRowContext(ctx, getType, idType)
	var i TbType
	err := row.Scan(&i.IDGroup, &i.IDType, &i.TypeName)
	return i, err
}

const getTypes = `-- name: GetTypes :many
select id_group, id_type, type_name
from tb_types
`

func (q *Queries) GetTypes(ctx context.Context) ([]TbType, error) {
	rows, err := q.db.QueryContext(ctx, getTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TbType
	for rows.Next() {
		var i TbType
		if err := rows.Scan(&i.IDGroup, &i.IDType, &i.TypeName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
